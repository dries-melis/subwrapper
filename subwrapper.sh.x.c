#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f subwrapper.sh -o bin/subwrapper 
#endif

static  char data [] = 
#define      pswd_z	256
#define      pswd	((&data[49]))
	"\302\136\063\004\300\140\167\221\275\142\353\002\036\246\136\327"
	"\137\331\275\024\260\355\224\307\045\013\257\175\265\363\166\022"
	"\256\347\202\353\331\121\160\254\336\353\006\010\374\036\176\026"
	"\064\106\277\004\320\360\213\120\061\215\307\100\035\367\353\172"
	"\012\274\131\354\053\327\023\241\241\027\275\122\247\155\347\203"
	"\050\002\052\047\073\107\360\237\303\033\123\165\002\066\154\004"
	"\315\111\001\237\105\110\223\322\165\245\032\052\355\040\171\341"
	"\046\261\032\203\237\204\371\317\260\276\204\343\046\311\313\024"
	"\013\171\147\113\261\242\221\307\250\066\373\174\046\251\260\303"
	"\264\370\005\126\133\152\350\152\342\271\177\030\371\260\130\046"
	"\176\204\261\006\075\143\271\363\343\354\052\030\201\213\161\371"
	"\201\010\345\111\303\032\165\301\144\171\274\222\140\021\333\052"
	"\364\112\373\276\337\273\223\316\322\373\135\204\237\317\025\302"
	"\134\074\305\051\022\125\031\015\062\365\045\367\346\245\050\005"
	"\303\173\230\073\372\312\260\372\066\233\176\055\373\066\243\352"
	"\140\032\057\312\120\123\373\336\310\350\254\271\254\053\327\363"
	"\305\053\132\066\353\230\311\050\200\070\224\173\264\031\345\305"
	"\043\266\375\227\241\330\011\066\104\365\275\377\151\252\113\135"
	"\304\002\270\055\056\066\155\122\323\252\250\015\175\316\262\025"
	"\334\165\073\007\302\202\052\365\216\344\370\306\104\302\374\275"
	"\325\263\173\220\221\176\016\233\043\030\360\131\206\073\117\336"
	"\155\014\301\067\150\247\031\334\066\166\135\041\277\231\137\002"
	"\374"
#define      tst1_z	22
#define      tst1	((&data[353]))
	"\077\355\147\320\201\005\104\266\161\066\351\371\040\234\115\233"
	"\313\250\076\071\306\045\110\330\377\006\152"
#define      msg2_z	19
#define      msg2	((&data[380]))
	"\245\202\301\001\171\051\210\114\377\360\311\145\306\117\265\302"
	"\357\236\261\344\176"
#define      msg1_z	65
#define      msg1	((&data[401]))
	"\237\020\167\105\232\257\022\347\367\115\145\213\125\372\310\273"
	"\201\210\355\034\335\030\271\104\043\152\021\035\140\360\252\004"
	"\376\264\054\152\355\000\135\117\173\210\061\044\044\034\154\312"
	"\130\167\341\315\121\016\114\043\023\166\343\235\206\056\301\127"
	"\355\007\357"
#define      chk1_z	22
#define      chk1	((&data[470]))
	"\061\001\315\201\107\366\362\020\042\140\251\330\263\211\207\253"
	"\065\203\026\053\375\270\333\141\307\047\052\046"
#define      inlo_z	3
#define      inlo	((&data[496]))
	"\377\244\226"
#define      rlax_z	1
#define      rlax	((&data[499]))
	"\225"
#define      chk2_z	19
#define      chk2	((&data[500]))
	"\026\005\334\051\115\101\151\300\011\256\310\222\316\233\163\010"
	"\160\022\046"
#define      date_z	1
#define      date	((&data[519]))
	"\334"
#define      tst2_z	19
#define      tst2	((&data[522]))
	"\350\054\226\247\101\310\064\321\212\221\300\064\242\013\041\307"
	"\060\144\073\121\037\153\012\252\165"
#define      shll_z	10
#define      shll	((&data[546]))
	"\366\005\251\072\322\116\351\116\174\232\277"
#define      xecc_z	15
#define      xecc	((&data[559]))
	"\050\106\355\042\212\257\034\025\267\067\206\037\227\036\064\304"
	"\171\376\105\114\027"
#define      lsto_z	1
#define      lsto	((&data[577]))
	"\274"
#define      opts_z	1
#define      opts	((&data[578]))
	"\021"
#define      text_z	2009
#define      text	((&data[774]))
	"\164\105\002\162\124\220\004\353\311\253\017\335\143\223\212\165"
	"\040\261\373\170\103\315\350\005\305\372\251\300\343\031\323\043"
	"\177\357\030\306\077\106\317\010\055\205\070\354\270\057\271\262"
	"\225\226\231\076\035\233\152\032\056\317\261\361\375\112\364\005"
	"\200\353\345\214\151\011\240\107\003\047\276\254\163\231\302\266"
	"\300\174\310\106\255\352\055\326\176\022\206\134\011\301\102\351"
	"\325\342\003\270\341\323\273\364\221\363\374\146\011\351\242\241"
	"\361\027\146\017\021\374\250\042\315\344\220\176\164\352\336\023"
	"\066\277\154\020\275\020\143\154\242\276\033\215\026\341\230\220"
	"\132\237\377\176\373\124\113\017\075\353\270\200\153\145\366\266"
	"\076\125\060\334\105\153\036\376\270\061\236\142\240\353\214\276"
	"\210\024\203\166\057\101\041\244\041\064\210\333\217\177\063\172"
	"\131\175\242\275\267\276\030\340\030\123\177\321\031\137\322\035"
	"\070\361\053\374\277\244\236\154\343\211\260\236\124\340\310\342"
	"\167\107\263\331\106\016\276\171\325\000\115\314\256\216\336\152"
	"\125\322\062\033\143\217\211\153\177\025\246\126\372\206\127\300"
	"\323\050\050\372\027\357\106\322\306\147\133\206\326\304\206\220"
	"\200\027\164\066\374\135\035\111\013\226\164\071\163\363\151\012"
	"\161\270\043\327\140\256\321\013\253\003\043\356\377\076\124\243"
	"\362\211\344\275\072\025\274\124\203\341\073\010\141\333\242\002"
	"\050\156\171\124\062\114\074\054\031\117\013\150\357\156\312\260"
	"\333\172\143\134\212\051\057\306\057\172\370\361\214\363\220\110"
	"\267\072\206\046\222\335\004\356\113\251\304\334\324\240\344\301"
	"\265\153\373\206\126\035\164\170\332\121\311\201\261\152\127\361"
	"\055\107\025\155\154\271\171\140\166\317\113\153\321\250\265\061"
	"\003\350\042\041\140\221\011\154\116\072\361\202\054\304\064\023"
	"\110\057\042\360\073\307\201\076\346\056\055\156\214\006\114\327"
	"\145\063\242\375\212\223\323\103\300\071\004\043\001\160\176\220"
	"\154\177\216\161\271\210\020\323\202\271\007\255\042\140\214\324"
	"\016\121\100\366\204\200\077\162\345\032\234\276\037\262\071\207"
	"\265\017\353\014\111\277\302\122\051\001\033\240\120\254\202\207"
	"\133\332\271\122\274\365\154\305\067\366\115\265\372\222\276\164"
	"\211\005\146\355\201\211\014\327\371\362\327\146\024\223\021\014"
	"\362\277\362\023\316\131\121\371\075\167\201\267\217\341\154\044"
	"\214\336\341\054\075\212\203\056\063\343\226\100\141\163\341\321"
	"\003\265\171\320\202\203\277\251\011\221\034\144\073\063\023\366"
	"\000\301\377\300\053\204\331\351\033\045\237\142\074\072\076\370"
	"\104\074\132\055\014\373\014\233\376\265\327\201\173\357\047\131"
	"\357\052\330\330\330\036\110\321\221\057\033\045\110\203\124\237"
	"\010\151\247\333\033\142\043\233\333\047\210\074\346\153\202\023"
	"\334\174\164\371\343\201\103\023\310\047\346\054\224\012\335\375"
	"\303\133\142\254\113\106\202\306\356\202\127\240\217\355\040\003"
	"\020\040\124\367\121\161\104\207\300\100\353\306\026\224\100\165"
	"\177\355\044\377\140\021\176\337\145\143\347\316\313\051\325\032"
	"\307\021\011\005\003\250\353\333\367\141\122\333\260\222\175\226"
	"\246\060\014\247\255\036\204\205\060\163\356\144\331\116\065\362"
	"\304\025\221\000\224\102\116\360\370\124\116\346\077\066\375\324"
	"\072\350\342\302\254\137\002\023\004\075\062\324\271\262\234\061"
	"\024\214\140\275\132\315\244\254\210\173\343\067\346\122\005\156"
	"\265\216\363\212\106\250\223\227\221\245\337\377\347\363\043\334"
	"\013\372\026\247\222\170\045\016\114\335\217\371\310\156\024\000"
	"\377\176\002\106\101\314\211\050\163\223\353\120\200\137\237\351"
	"\077\230\277\146\147\077\346\033\252\134\315\227\152\153\243\357"
	"\177\102\072\007\122\351\013\276\160\004\154\107\201\227\314\341"
	"\314\203\047\334\207\130\313\070\120\105\312\022\157\162\277\107"
	"\305\100\330\027\243\114\204\175\215\236\001\316\046\127\020\271"
	"\336\262\150\227\212\314\025\210\355\232\245\155\326\077\221\214"
	"\125\371\230\261\302\021\243\360\354\142\274\052\337\371\035\215"
	"\363\055\251\151\323\347\030\050\017\150\061\015\270\235\223\207"
	"\077\204\140\171\022\235\224\063\344\151\123\034\254\170\043\301"
	"\217\315\033\053\371\052\045\324\340\021\241\313\101\246\165\127"
	"\332\362\070\251\317\261\361\036\301\232\265\201\254\213\344\040"
	"\142\103\030\367\325\021\041\276\373\233\066\171\332\227\051\130"
	"\301\355\363\133\336\062\015\246\060\005\203\307\247\245\032\212"
	"\315\114\001\325\263\162\240\210\052\314\236\223\204\016\021\015"
	"\004\330\036\361\077\356\021\233\214\100\222\254\157\344\330\317"
	"\236\331\131\043\106\030\052\173\374\255\235\055\016\322\140\154"
	"\345\346\164\051\371\076\224\152\136\030\011\002\165\175\203\327"
	"\165\146\217\247\064\351\337\050\111\160\310\271\306\012\212\336"
	"\147\313\163\124\137\115\157\327\331\016\036\220\206\010\375\133"
	"\202\123\312\036\277\233\204\056\057\016\176\230\335\267\105\270"
	"\076\040\344\043\142\125\361\147\224\034\314\152\201\046\072\265"
	"\174\210\075\172\323\172\072\004\042\304\275\076\066\336\123\172"
	"\154\167\004\361\114\225\237\313\215\157\243\277\252\030\374\210"
	"\057\171\000\000\160\246\254\363\122\147\200\254\224\320\250\145"
	"\121\174\337\140\061\016\253\373\301\243\370\314\314\357\300\362"
	"\124\212\230\004\276\134\253\332\003\206\103\320\372\360\201\151"
	"\066\113\150\211\156\107\034\360\155\172\200\253\317\211\203\111"
	"\037\117\161\115\214\122\254\106\306\257\212\237\152\307\073\227"
	"\127\077\032\244\371\241\010\077\233\354\334\346\324\140\264\317"
	"\341\305\346\223\314\247\241\261\241\251\257\066\173\027\152\116"
	"\002\266\046\230\245\255\103\337\265\355\251\274\331\164\122\306"
	"\351\034\127\323\351\251\304\303\210\230\167\317\342\002\237\014"
	"\033\310\363\357\105\053\066\315\160\152\037\150\125\103\226\324"
	"\252\236\377\141\224\205\040\110\127\003\062\077\236\021\152\153"
	"\162\201\076\353\034\025\362\303\256\141\233\155\071\066\332\073"
	"\173\313\076\153\144\150\203\061\146\220\067\333\325\306\043\005"
	"\217\351\174\066\261\165\112\225\125\241\107\054\104\106\245\302"
	"\107\244\366\360\267\106\117\357\304\000\042\234\375\114\171\112"
	"\145\126\373\032\174\057\212\350\074\163\340\274\361\343\007\055"
	"\344\357\272\227\314\107\335\240\277\145\202\037\123\201\167\132"
	"\343\177\231\116\007\055\242\101\016\127\336\302\362\200\115\074"
	"\046\176\132\033\054\062\267\273\322\033\157\303\214\001\320\010"
	"\344\125\212\173\017\206\070\126\221\233\337\255\237\010\355\157"
	"\224\121\065\366\156\020\064\113\115\201\154\360\322\017\274\256"
	"\227\063\013\364\346\237\153\106\075\042\103\216\142\035\251\263"
	"\002\314\261\115\335\217\271\330\010\221\121\216\173\201\115\310"
	"\002\327\257\311\266\171\301\350\106\222\333\146\336\373\161\312"
	"\331\003\130\043\202\221\343\115\276\232\376\264\105\345\004\307"
	"\262\342\236\351\237\074\373\220\250\304\205\004\002\147\277\037"
	"\110\360\363\126\167\112\343\302\015\352\363\023\273\376\231\222"
	"\364\344\154\343\170\357\244\245\121\146\255\273\011\041\304\065"
	"\232\201\347\162\051\224\156\050\050\161\150\275\300\001\271\044"
	"\143\305\263\322\217\260\315\337\201\256\067\303\111\245\345\102"
	"\326\311\316\165\030\202\134\373\367\023\103\170\263\132\116\044"
	"\257\111\146\033\047\130\170\075\257\154\227\027\014\005\331\307"
	"\272\031\025\353\344\167\167\122\353\346\177\301\066\136\111\340"
	"\307\344\017\006\122\025\362\147\370\142\306\007\207\367\011\305"
	"\133\133\045\213\171\170\274\325\070\172\210\011\254\110\243\005"
	"\003\342\112\366\240\326\261\317\334\337\246\172\301\007\313\010"
	"\032\052\123\240\056\157\260\245\307\311\142\363\270\315\216\253"
	"\301\074\342\007\126\313\140\077\022\154\150\022\154\066\261\374"
	"\020\321\155\245\342\351\050\377\336\170\024\357\342\205\305\003"
	"\112\255\053\042\253\172\265\221\037\072\027\326\133\323\071\261"
	"\013\012\166\023\277\165\123\101\262\315\314\377\260\315\146\235"
	"\311\076\253\364\075\041\154\065\064\260\030\274\166\342\271\070"
	"\347\172\065\120\220\025\313\142\226\017\015\130\144\326\324\254"
	"\273\032\144\173\013\247\212\330\337\230\122\206\303\171\022\305"
	"\241\361\030\246\041\031\363\321\106\016\313\036\372\373\077\345"
	"\110\144\203\243\307\165\144\130\211\317\277\114\104\004\276\026"
	"\234\224\026\100\314\374\141\020\016\314\145\350\254\127\027\166"
	"\325\107\234\222\313\256\164\145\117\327\057\310\303\177\265\242"
	"\323\346\156\044\372\070\306\310\114\337\323\171\161\042\256\071"
	"\315\237\075\341\176\056\206\072\160\322\320\152\341\337\334\331"
	"\042\230\314\064\053\076\267\003\242\055\313\126\016\105\345\131"
	"\320\264\206\140\121\017\144\213\367\314\145\245\365\275\361\300"
	"\313\021\022\270\237\253\361\353\220\303\166\336\322\263\371\036"
	"\114\063\165\346\047\145\076\371\145\367\323\041\147\121\010\276"
	"\250\357\376\273\227\205\310\155\041\346\075\372\021\164\073\134"
	"\303\100\357\063\030\176\202\021\317\101\070\064\202\322\266\126"
	"\007\261\234\001\033\325\102\224\063\021\223\225\064\052\301\070"
	"\303\376\116\023\361\344\310\214\022\003\157\321\176\062\322\377"
	"\373\377\362\016\145\247\134\065\262\373\375\166\143\210\166\220"
	"\203\370\044\040\200\355\036\066\036\351\030\300\357\020\066\010"
	"\176\165\315\270\375\060\327\261\214\140\164\015\024\036\300\161"
	"\350\070\000\134\137\300\133\213\103\251\235\144\112\306\005\351"
	"\305\247\306\213\352\305\270\270\120\365\323\141\356\113\320\260"
	"\055\033\341\002\361\317\067\200\356\325\061\377\243\132\236\345"
	"\126\006\065\073\172\226\023\041\270\130\260\053\367\177\301\212"
	"\065\160\053\005\073\320\033\324\075\111\003\300\243\121\234\362"
	"\332\032\232\350\004\315\023\013\115\366\055\331\242\173"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
