#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f subwrapper.sh -o ./bin/subwrapper 
#endif

static  char data [] = 
#define      date_z	1
#define      date	((&data[0]))
	"\125"
#define      chk2_z	19
#define      chk2	((&data[3]))
	"\317\014\250\322\014\374\316\143\213\350\365\122\204\375\364\234"
	"\131\001\316\370\060\055\203\111\376"
#define      pswd_z	256
#define      pswd	((&data[77]))
	"\143\070\327\316\050\266\030\364\041\320\031\122\301\304\120\065"
	"\155\237\113\262\010\347\054\350\044\052\355\072\022\046\053\307"
	"\331\035\161\067\220\172\366\213\361\110\364\372\147\165\102\235"
	"\332\004\370\135\237\155\264\223\103\231\017\122\026\257\040\075"
	"\215\244\330\372\307\140\113\072\301\243\230\001\022\304\066\356"
	"\123\006\161\260\070\325\374\047\176\325\352\272\046\266\337\202"
	"\353\176\154\164\124\263\337\260\261\377\172\005\311\013\301\105"
	"\127\150\150\375\062\036\023\106\212\127\144\220\275\072\334\177"
	"\231\230\101\376\055\200\172\121\112\024\051\016\177\341\014\044"
	"\360\012\204\371\017\371\376\224\014\111\047\205\307\004\135\157"
	"\225\056\332\355\314\160\111\336\361\351\047\115\252\051\242\307"
	"\335\254\054\167\061\327\061\165\201\163\311\010\105\100\223\356"
	"\157\121\203\257\130\143\155\041\242\314\372\120\002\074\073\341"
	"\137\250\334\371\233\232\143\227\147\310\041\220\022\340\065\166"
	"\077\027\353\164\010\200\346\126\166\051\075\132\022\116\233\343"
	"\154\012\204\306\073\350\010\001\377\130\336\252\242\274\367\012"
	"\232\176\064\336\172\373\023\035\210\143\015\000\263\046\211\300"
	"\055\271\213\014\353\153\251\060\077\013\065\224\224\227\231\166"
	"\310\043\301\100\257\360\116\117\245\111\120\037\214\317\170\304"
	"\012\373\363\205\272\253\064\240\326\136\062\110\313\230\376\032"
	"\037\051\044\007\070\200\307\376\066\151\250\377\245\153\204\131"
	"\302\067\237\270\002\312\330\044\317\202\313\071\272\033\021"
#define      lsto_z	1
#define      lsto	((&data[377]))
	"\070"
#define      shll_z	10
#define      shll	((&data[378]))
	"\246\053\345\077\014\234\335\161\322\360"
#define      text_z	2005
#define      text	((&data[759]))
	"\121\165\031\220\363\376\376\220\342\317\071\044\150\216\277\240"
	"\035\177\122\120\103\264\151\026\116\232\116\211\064\166\334\216"
	"\275\115\204\031\373\321\231\227\031\112\165\113\211\353\335\164"
	"\032\053\060\347\146\135\077\120\267\303\363\277\176\326\101\072"
	"\215\042\320\115\023\047\307\251\015\325\244\151\062\204\247\174"
	"\153\151\302\030\035\341\143\003\233\113\265\034\244\035\353\273"
	"\055\305\074\201\304\240\065\202\147\220\145\277\141\323\161\306"
	"\116\226\331\176\053\264\071\015\020\073\301\174\372\226\150\205"
	"\241\002\047\213\332\320\211\255\176\003\015\023\336\154\250\270"
	"\220\341\056\315\042\310\216\004\352\050\120\240\116\261\334\332"
	"\166\156\056\217\050\000\244\331\276\307\164\215\126\215\344\261"
	"\161\154\235\012\356\224\122\302\277\376\112\163\237\076\014\235"
	"\001\142\364\237\334\152\062\365\333\367\341\154\227\010\137\120"
	"\051\047\376\307\217\000\067\343\341\255\057\276\306\325\304\346"
	"\332\173\050\273\242\230\060\212\246\131\125\205\174\016\337\337"
	"\232\354\064\030\225\043\042\302\204\137\250\321\340\316\201\114"
	"\155\251\061\144\341\245\123\145\006\104\106\134\355\040\316\006"
	"\171\014\163\054\014\074\016\317\376\247\117\337\045\157\230\345"
	"\175\373\252\150\076\265\257\235\131\322\005\020\270\175\352\256"
	"\373\127\051\075\135\323\316\104\051\136\130\276\155\112\131\306"
	"\012\255\205\063\063\347\010\035\166\021\010\346\211\057\301\336"
	"\376\061\000\025\277\301\021\161\165\127\107\266\032\123\046\122"
	"\150\065\325\070\366\026\232\254\175\111\004\177\113\367\166\245"
	"\142\251\147\257\021\107\330\047\236\005\313\036\354\032\136\307"
	"\234\220\031\170\325\371\201\325\321\105\135\057\065\271\134\176"
	"\320\371\013\066\156\050\324\114\265\320\307\314\256\374\163\053"
	"\303\071\311\100\155\024\061\361\202\362\101\026\355\175\235\361"
	"\364\306\237\375\100\157\213\375\041\334\216\311\323\041\071\222"
	"\363\053\204\223\066\214\004\236\235\165\172\040\135\167\236\072"
	"\270\172\077\123\034\146\336\102\142\264\041\226\125\236\361\043"
	"\163\265\037\136\201\330\221\344\050\106\051\165\122\163\220\310"
	"\272\060\077\125\276\367\014\347\130\251\214\155\200\022\336\150"
	"\010\031\340\313\324\142\076\323\367\135\076\155\134\301\362\045"
	"\101\315\130\042\227\306\325\276\025\247\370\040\035\037\306\362"
	"\272\275\336\307\302\212\373\117\246\354\225\133\377\142\254\030"
	"\377\000\074\335\207\330\027\201\203\354\314\343\113\224\141\006"
	"\007\167\165\233\232\373\345\012\042\060\006\207\234\177\171\153"
	"\001\100\135\145\227\261\040\266\012\075\312\062\270\040\267\055"
	"\051\312\262\002\372\360\016\144\315\316\227\045\345\164\356\157"
	"\222\172\371\151\360\105\311\317\132\246\222\056\336\172\006\373"
	"\207\113\257\065\040\302\311\047\007\130\227\346\054\073\054\213"
	"\250\133\145\241\211\147\036\237\227\364\051\135\161\003\313\273"
	"\054\122\035\064\223\075\343\002\251\133\373\172\026\273\137\330"
	"\103\355\014\322\100\162\070\350\317\341\235\227\314\372\055\246"
	"\011\325\165\317\204\054\175\120\243\217\066\045\343\002\236\377"
	"\067\166\205\011\231\034\237\272\042\260\206\040\262\055\070\371"
	"\204\111\216\146\122\135\223\337\017\111\260\077\241\134\255\122"
	"\130\247\360\125\106\006\222\365\304\353\274\022\037\310\277\050"
	"\107\030\355\370\254\005\251\347\075\227\343\036\061\366\243\177"
	"\325\361\207\242\133\055\251\247\067\253\106\350\355\305\317\104"
	"\262\376\055\360\345\043\152\103\143\171\070\074\031\362\014\033"
	"\152\370\302\217\251\121\026\262\315\224\102\052\342\202\157\033"
	"\012\343\264\305\336\335\130\314\053\046\325\300\126\035\247\351"
	"\203\336\221\042\375\264\050\166\026\157\344\212\011\322\032\114"
	"\046\307\071\276\312\174\302\272\012\113\210\237\023\360\315\145"
	"\214\374\034\321\106\107\060\253\357\334\363\101\001\154\102\063"
	"\011\323\360\155\136\041\104\155\136\042\240\334\145\210\041\357"
	"\102\054\324\356\324\314\106\342\051\331\161\013\361\336\334\034"
	"\067\074\173\151\167\142\221\203\034\020\322\374\001\331\233\174"
	"\277\126\354\011\302\102\245\103\225\114\131\122\247\371\134\244"
	"\052\213\037\337\354\245\306\113\032\004\323\063\071\274\211\162"
	"\060\012\146\315\351\364\347\117\155\265\312\221\077\363\073\205"
	"\150\266\177\344\330\111\117\214\176\371\007\216\224\317\070\043"
	"\042\275\106\127\176\323\007\061\171\176\177\203\210\365\366\033"
	"\203\302\162\345\042\064\335\156\332\276\157\353\127\051\037\226"
	"\304\046\234\257\171\013\137\123\376\331\123\022\146\167\151\210"
	"\103\375\074\046\063\356\052\327\355\070\155\361\337\174\344\345"
	"\154\257\104\150\243\333\045\367\023\341\222\267\077\342\124\350"
	"\267\000\146\170\304\240\103\256\007\270\157\070\150\167\351\061"
	"\157\024\131\116\313\002\240\020\311\011\102\042\235\070\174\007"
	"\354\142\203\121\136\375\337\116\072\175\304\051\074\300\247\127"
	"\137\367\261\347\277\061\120\034\323\057\376\263\003\257\124\125"
	"\343\140\070\141\373\110\057\150\140\075\162\347\252\014\171\147"
	"\023\145\054\355\367\064\203\060\121\140\046\057\245\233\125\176"
	"\105\055\342\062\066\215\150\160\143\076\251\176\133\340\151\356"
	"\375\061\070\111\374\021\274\335\040\360\055\354\017\226\054\350"
	"\152\063\045\163\017\277\056\100\346\175\270\251\077\306\331\214"
	"\212\100\000\357\275\105\035\161\137\103\015\013\010\113\075\375"
	"\364\250\241\332\121\316\152\306\076\251\054\021\325\320\016\035"
	"\051\006\310\317\057\343\164\342\323\364\373\272\377\052\245\177"
	"\274\154\215\075\252\313\360\231\165\022\265\337\016\377\326\364"
	"\131\014\340\255\162\106\023\153\352\100\035\121\343\030\361\233"
	"\064\102\030\317\152\325\130\012\110\370\055\334\212\173\367\337"
	"\314\062\213\330\107\226\017\075\145\211\203\137\352\047\050\047"
	"\212\026\231\256\050\345\116\030\365\355\320\313\303\240\004\067"
	"\344\104\310\375\020\227\037\243\007\102\341\117\060\270\176\335"
	"\140\257\016\150\036\267\006\371\111\340\374\262\364\117\141\074"
	"\222\134\355\011\204\214\377\066\146\335\312\263\312\225\052\144"
	"\113\057\152\112\304\216\044\060\157\370\216\232\332\137\271\014"
	"\022\114\317\023\004\222\270\321\167\252\300\337\371\371\053\113"
	"\033\266\115\300\017\056\211\052\225\072\116\360\374\051\233\303"
	"\123\140\157\067\140\152\043\235\227\352\367\133\257\160\304\217"
	"\363\245\131\020\167\002\012\302\316\214\272\237\265\252\332\316"
	"\155\325\031\171\255\265\277\166\112\043\237\141\146\307\045\103"
	"\377\260\320\321\050\334\352\260\165\345\216\223\031\150\360\125"
	"\234\247\204\364\120\036\231\325\343\141\210\236\042\142\301\107"
	"\260\174\176\225\365\044\230\172\046\026\015\264\024\132\303\272"
	"\253\116\172\363\265\333\165\166\325\152\365\254\222\323\142\361"
	"\327\105\011\262\260\150\300\225\340\150\374\162\170\233\174\116"
	"\335\245\370\313\332\251\035\163\206\275\274\020\337\071\220\200"
	"\055\053\025\124\211\300\343\065\101\332\075\164\272\071\307\014"
	"\113\025\037\361\252\122\134\264\314\272\206\116\350\126\114\077"
	"\024\361\136\210\321\326\257\371\052\275\023\064\305\167\063\027"
	"\316\201\012\275\015\272\110\004\016\345\146\005\134\374\201\226"
	"\250\236\236\024\366\170\353\173\034\006\335\365\201\305\127\043"
	"\340\236\354\130\252\302\163\161\230\112\320\006\336\301\121\325"
	"\360\277\227\375\125\061\031\373\160\100\357\323\317\227\272\367"
	"\231\015\250\221\211\222\014\311\330\155\214\307\245\057\113\304"
	"\240\334\172\147\353\045\211\316\262\163\374\351\372\027\262\033"
	"\017\213\345\110\230\341\320\277\264\236\321\215\035\377\172\314"
	"\136\274\013\102\131\177\070\054\054\301\255\315\303\037\013\064"
	"\351\234\265\251\277\241\371\173\347\207\200\066\272\230\323\052"
	"\317\367\364\340\116\133\244\174\011\272\371\121\126\132\342\135"
	"\161\123\271\156\203\355\003\332\010\073\144\134\276\172\231\061"
	"\120\020\267\115\205\243\360\345\120\370\325\207\140\213\360\126"
	"\063\255\103\262\146\371\076\163\307\350\342\245\366\117\110\304"
	"\051\331\247\270\346\337\231\275\126\106\354\033\225\124\060\162"
	"\117\152\136\262\164\136\171\322\272\350\110\327\060\074\104\222"
	"\127\306\035\353\234\101\351\261\136\300\274\353\137\030\214\045"
	"\007\223\266\113\061\342\173\225\346\262\261\022\213\031\255\323"
	"\022\043\002\200\104\062\346\173\170\236\032\373\023\313\304\143"
	"\251\007\235\225\144\131\070\066\177\130\174\024\007\026\177\234"
	"\117\140\252\074\207\313\234\167\344\107\252\017\071\077\247\052"
	"\124\073\015\051\216\175\342\142\114\121\032\174\223\376\345\266"
	"\355\365\221\244\143\351\122\056\024\054\022\333\263\335\214\252"
	"\251\011\041\236\122\274\213\171\147\331\150\222\176\145\105\324"
	"\010\370\375\252\035\105\177\126\053\332\364\347\354\244\167\002"
	"\373\370\077\235\247\165\042\116\010\011\207\127\153\107\340\130"
	"\315\160\336\252\372\357\247\226\344\013\225\245\172\155\172\065"
	"\105\273\007\070\177\122\007\243\004\224\051\112\103\227\065\132"
	"\001\075\002\225\162\335\021\117\004\023\141\100\161\043\100\361"
	"\170\124\225\017\035\014\063\106\043\047\024\350\271\205\327\076"
	"\237\116\270\174\361\012\124\101\360\342\320\116\360\271\375\271"
	"\260\361\167\067\162\034\321\253\230\154\272\125\314\164\236\045"
	"\136\161\157\015\137\030\341\264\052\301\043\120\066\227\207\103"
	"\270\371\244\171\065\327\257\226\115\145\044\277\171\342\333\111"
	"\120\303\112\051\136\333\042\376\243\116\203\222\075\116\261\046"
	"\001\257\240\012\073\065\142\167\266\032\213\272\235\357\137\103"
	"\114\101\050\355\211\247\050\131\316\357\104\203\134\100\143\247"
	"\300\063\343\212\303\336\213\342\221\321\257\101\342\332\226\023"
	"\230\113\140\104\370\204\024\156\254\217\114\161\044\020\367\225"
	"\370\177\332\046\262\032\224\162\117\212\155\167\310\035\137\130"
	"\136\334\151\036\316\346\075\376\027\254\224\146\002\231\361\070"
	"\252\320\341\373\235\351\073\306\226\171\236\255\311\017\040\271"
	"\351\134\070\107\264\266\167\263\115\105\053\302\303\213\251\357"
	"\234\225\005\361\241\276\161\275\237\332\043\053\147\266\245\346"
	"\164\055\223\325\057\127\223\335\054\347\260\173\142\367\070\337"
	"\057\306\362\060\326\237\165\306\355\142\210\232\221\213\245\332"
	"\277\212\164\203\060\140\072\225\361\361\146\321\160\154\154\103"
	"\225\125\246\007\161\131\263\040\377\023\257\321\106\305\346\005"
	"\165\017\203\062\206\163\270\137\320\264\232\047\124\303\061\125"
	"\204\107\111\137\326\011\321\330\004\122\310\316\022\064\330\173"
	"\376\036\314\326\201\330\011\167\055\155\024\362\337\156\222\217"
	"\063\177\071\125\322\336\175\331\006\136\267\070\272\000\346\131"
	"\222\031\303\373\330\005"
#define      inlo_z	3
#define      inlo	((&data[2858]))
	"\330\242\271"
#define      xecc_z	15
#define      xecc	((&data[2861]))
	"\311\270\307\307\031\157\003\326\162\230\146\211\237\100\153\054"
#define      tst1_z	22
#define      tst1	((&data[2881]))
	"\206\362\120\163\155\227\173\201\016\007\125\204\124\150\224\313"
	"\163\201\136\200\042\330\000\311\375\251\326\142\225\205"
#define      msg1_z	65
#define      msg1	((&data[2915]))
	"\335\152\033\013\113\013\272\036\011\016\355\241\215\036\300\311"
	"\363\267\123\104\057\320\370\333\216\076\255\022\205\344\122\152"
	"\030\165\031\163\047\262\216\310\025\135\313\366\320\003\022\172"
	"\305\236\162\036\245\000\237\234\311\231\176\314\036\376\012\012"
	"\255\213\046\246\347\315\244\204\212\375\000"
#define      rlax_z	1
#define      rlax	((&data[2982]))
	"\165"
#define      chk1_z	22
#define      chk1	((&data[2983]))
	"\136\052\322\121\244\346\022\175\210\355\373\306\006\273\370\031"
	"\314\017\051\327\067\305\212\235\067\046"
#define      msg2_z	19
#define      msg2	((&data[3010]))
	"\261\360\327\274\323\225\267\076\002\220\122\005\253\175\375\136"
	"\055\043\122\133\071\366\160"
#define      opts_z	1
#define      opts	((&data[3032]))
	"\215"
#define      tst2_z	19
#define      tst2	((&data[3036]))
	"\252\201\372\224\030\217\240\063\207\237\377\002\212\145\333\334"
	"\032\057\123\052\215\037"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
