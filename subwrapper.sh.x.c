#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f subwrapper.sh -o bin/subwrapper 
#endif

static  char data [] = 
#define      inlo_z	3
#define      inlo	((&data[0]))
	"\207\323\334"
#define      text_z	2005
#define      text	((&data[200]))
	"\206\071\156\207\056\053\276\217\010\004\253\266\336\176\376\230"
	"\055\227\064\026\340\142\205\243\372\333\352\041\266\001\236\077"
	"\175\136\025\204\233\021\136\307\132\224\121\247\056\267\202\341"
	"\144\313\140\027\036\207\341\363\272\375\275\051\006\032\222\126"
	"\051\003\240\154\166\353\334\105\334\016\247\361\336\374\103\055"
	"\123\204\022\054\314\257\376\121\041\215\176\055\011\011\314\312"
	"\047\164\246\113\077\053\215\177\152\210\364\114\267\106\370\145"
	"\153\011\211\111\365\367\144\131\150\165\370\350\041\357\344\144"
	"\253\021\050\210\310\205\171\036\100\063\066\270\120\341\051\023"
	"\067\257\317\142\357\213\242\326\303\237\375\041\340\020\231\234"
	"\273\163\343\267\101\166\374\333\352\377\204\264\376\034\225\331"
	"\262\043\172\170\232\220\111\221\246\167\276\072\006\327\202\060"
	"\367\041\043\272\250\157\122\122\150\040\074\056\351\071\327\176"
	"\274\124\112\262\324\011\046\071\035\213\250\336\332\006\212\026"
	"\160\367\266\040\246\067\122\374\246\323\110\350\214\360\015\124"
	"\313\130\132\007\056\324\176\214\256\017\304\024\345\233\312\237"
	"\041\353\107\054\341\200\374\172\152\317\372\241\270\067\151\120"
	"\037\071\201\305\215\067\046\124\301\217\164\040\353\014\071\015"
	"\231\350\006\004\150\354\373\322\215\077\303\320\275\341\203\246"
	"\255\374\240\322\121\171\060\034\023\211\335\260\256\156\045\071"
	"\250\044\012\320\327\007\125\227\055\120\305\316\226\203\121\124"
	"\167\330\243\267\126\341\370\204\371\257\132\377\016\166\062\040"
	"\247\057\343\121\261\010\223\333\103\365\213\356\131\337\027\214"
	"\234\147\016\322\066\111\124\341\215\315\035\016\353\324\011\204"
	"\137\060\267\116\176\331\231\315\035\100\323\147\011\020\111\034"
	"\377\101\015\027\203\164\150\057\066\301\065\134\256\324\213\110"
	"\276\010\132\043\272\177\305\120\345\333\331\236\002\151\056\236"
	"\006\254\270\141\265\213\377\245\320\355\146\010\376\266\070\070"
	"\053\206\240\372\136\334\176\265\243\003\216\344\270\113\250\111"
	"\066\033\103\047\344\023\351\312\013\171\315\231\312\140\051\166"
	"\116\202\010\325\045\152\375\011\341\107\167\100\261\232\111\312"
	"\235\040\267\355\267\200\360\325\234\056\335\126\132\004\020\257"
	"\253\032\137\031\047\240\345\145\027\076\352\202\374\227\210\017"
	"\107\371\346\134\170\257\367\127\143\112\015\317\301\074\235\303"
	"\316\004\216\160\326\114\374\362\244\257\105\015\230\007\115\025"
	"\041\302\014\332\001\027\322\325\076\226\310\066\020\275\020\274"
	"\002\066\034\205\354\067\313\301\061\005\347\037\002\363\323\254"
	"\361\031\024\064\046\062\231\233\353\364\323\377\274\310\150\340"
	"\314\243\372\150\060\300\246\320\064\354\003\012\053\210\336\111"
	"\327\327\176\221\064\147\245\245\303\177\341\373\027\364\023\046"
	"\046\220\125\160\223\314\250\360\040\257\340\163\205\353\041\213"
	"\232\222\332\300\276\333\220\333\273\115\230\230\016\243\061\320"
	"\026\332\376\206\322\042\040\355\115\063\276\140\170\133\356\310"
	"\054\037\242\151\135\100\245\354\126\014\016\050\161\322\123\200"
	"\362\120\236\021\247\121\362\253\255\205\071\000\110\343\344\120"
	"\005\226\361\233\361\303\344\275\261\374\356\343\115\054\140\057"
	"\324\244\165\055\130\317\365\112\007\102\110\001\033\305\302\143"
	"\226\062\101\106\244\232\336\242\332\340\065\136\013\341\065\021"
	"\133\036\204\157\342\142\202\230\063\266\317\077\240\160\210\073"
	"\015\072\142\155\237\014\365\074\014\135\371\130\263\021\061\222"
	"\164\141\133\343\315\067\275\324\240\266\251\166\251\245\322\155"
	"\302\312\243\332\366\262\237\120\236\020\375\374\014\256\346\343"
	"\225\175\060\155\267\107\346\311\106\334\374\242\304\351\075\037"
	"\315\304\354\011\060\273\225\162\055\265\136\251\166\355\265\210"
	"\167\117\105\215\045\016\137\303\271\273\020\322\133\113\122\311"
	"\157\124\153\122\353\113\062\115\170\257\237\054\302\117\255\037"
	"\222\041\104\253\172\171\027\131\116\225\243\236\173\221\076\215"
	"\377\275\004\210\373\125\317\144\245\310\347\074\056\360\317\154"
	"\302\215\134\014\350\070\163\135\000\204\101\334\157\344\102\377"
	"\355\357\234\361\143\330\000\050\312\032\012\076\333\261\364\372"
	"\011\125\156\352\073\372\052\077\272\012\351\371\110\342\213\134"
	"\002\147\270\032\054\005\122\146\063\321\214\376\341\121\031\040"
	"\334\205\033\335\236\031\030\145\077\325\125\046\275\351\054\376"
	"\367\215\005\076\150\137\276\040\014\233\116\007\052\252\262\040"
	"\000\273\227\333\242\117\071\305\116\172\125\154\314\370\266\166"
	"\150\000\041\034\134\252\122\120\233\070\356\045\336\276\372\131"
	"\333\334\374\076\223\015\173\367\330\270\211\256\304\226\137\334"
	"\005\331\017\044\222\247\177\144\355\332\100\254\221\260\226\031"
	"\121\317\322\262\224\101\031\034\046\207\236\057\015\225\041\062"
	"\131\346\377\343\302\220\225\015\314\367\116\346\010\330\331\303"
	"\341\050\360\015\024\245\346\105\155\100\135\356\203\211\025\204"
	"\062\262\133\017\176\302\263\124\022\200\074\167\127\211\246\201"
	"\275\251\307\146\045\271\315\311\202\363\001\317\141\146\203\362"
	"\147\246\104\113\041\063\323\055\257\006\073\310\314\106\137\354"
	"\012\107\241\073\001\213\013\070\370\340\177\173\011\316\152\060"
	"\100\067\107\006\000\305\312\174\370\132\046\311\044\266\264\171"
	"\172\163\116\147\357\107\105\334\352\075\270\321\011\026\064\017"
	"\237\274\047\076\317\243\131\326\221\115\075\063\345\260\037\331"
	"\214\367\202\310\151\241\164\244\263\115\300\021\213\227\316\145"
	"\055\236\162\313\026\050\344\275\037\012\160\375\070\317\161\063"
	"\157\177\065\203\310\072\172\137\227\016\327\260\036\267\177\171"
	"\316\205\205\321\336\350\124\227\364\031\123\012\312\343\062\366"
	"\066\362\015\336\127\303\265\234\276\310\101\374\062\172\227\233"
	"\160\375\155\332\111\252\022\204\346\174\316\066\130\133\162\331"
	"\052\103\260\252\241\043\141\130\027\064\172\161\266\025\133\264"
	"\002\016\022\224\126\314\207\364\311\221\222\326\111\131\124\007"
	"\222\325\020\374\360\122\023\245\224\212\060\243\116\012\232\227"
	"\315\053\022\010\076\163\164\041\356\167\230\263\342\104\244\132"
	"\121\020\204\115\027\243\304\120\324\117\070\320\153\041\300\163"
	"\122\007\166\106\113\245\272\122\206\074\001\020\203\324\077\017"
	"\205\101\143\366\345\311\037\243\352\220\077\107\177\077\174\004"
	"\031\331\343\005\143\251\006\153\271\002\343\133\057\033\251\370"
	"\017\223\365\321\164\373\321\206\032\273\161\215\330\123\061\017"
	"\210\276\321\323\304\373\155\333\322\340\341\357\375\207\033\311"
	"\154\211\304\207\232\313\264\275\112\320\234\074\201\044\211\131"
	"\350\204\174\301\212\036\351\212\103\107\375\324\345\352\334\302"
	"\225\322\005\231\163\270\023\366\276\032\357\223\030\060\144\102"
	"\062\227\231\361\157\301\133\332\136\271\271\326\371\010\271\254"
	"\273\253\223\212\245\071\022\255\127\037\037\253\226\322\204\355"
	"\060\276\111\256\022\375\221\124\233\250\345\211\055\146\164\056"
	"\175\301\304\331\043\051\165\252\213\241\374\373\227\032\065\275"
	"\311\264\206\043\136\146\242\316\314\307\003\301\305\344\153\272"
	"\023\360\161\026\142\055\151\131\115\243\246\366\165\020\274\340"
	"\110\153\305\227\064\126\062\213\134\227\056\114\216\050\343\106"
	"\070\032\244\350\372\024\302\074\326\163\020\242\214\105\035\014"
	"\220\056\232\141\224\144\237\304\215\335\360\063\272\152\211\244"
	"\210\012\242\247\344\004\375\043\036\103\153\211\222\140\137\142"
	"\261\347\100\313\205\050\320\360\251\074\135\264\075\333\141\324"
	"\341\062\127\124\160\153\235\027\373\262\321\367\063\272\025\056"
	"\303\012\126\353\077\222\013\270\103\001\141\274\207\142\073\037"
	"\367\000\056\140\010\320\114\164\103\305\162\004\337\015\232\136"
	"\266\222\012\270\022\005\225\142\215\377\200\167\250\145\344\346"
	"\153\134\200\315\004\030\322\150\046\373\330\036\150\250\112\020"
	"\030\155\161\302\245\247\336\134\065\170\226\240\345\332\347\223"
	"\165\357\047\006\007\111\235\042\154\211\074\057\323\336\132\363"
	"\152\223\011\166\160\047\165\100\260\021\066\065\067\061\343\005"
	"\046\202\364\204\310\310\004\332\037\110\132\223\106\103\165\303"
	"\056\316\031\171\150\023\121\327\337\333\167\312\335\254\156\255"
	"\237\110\014\045\006\023\171\074\362\114\055\373\117\024\247\166"
	"\001\336\066\104\101\036\030\013\137\230\122\001\363\051\124\027"
	"\177\336\044\243\335\051\240\324\172\333\211\205\351\320\147\123"
	"\147\270\041\222\022\136\077\355\316\142\172\330\231\122\100\346"
	"\052\301\201\174\302\373\025\340\213\155\032\245\360\062\117\043"
	"\356\152\055\331\360\256\141\375\364\114\004\220\072\247\116\172"
	"\264\140\037\175\132\350\356\007\324\303\246\146\154\276\102\011"
	"\240\045\274\067\170\255\167\164\163\155\056\233\006\124\250\172"
	"\117\164\111\266\136\100\137\201\002\353\300\225\043\024\247\346"
	"\320\201\322\035\344\137\114\276\356\354\177\300\054\130\350\061"
	"\340\215\100\107\203\231\176\124\046\132\165\152\112\305\116\220"
	"\323\154\122\044\224\257\024\312\050\240\173\354\135\345\304\261"
	"\324\376\157\107\032\310\076\367\310\062\140\364\335\257\302\163"
	"\327\312\200\055\336\272\012\205\272\031\043\220\336\106\172\265"
	"\323\313\161\305\070\123\321\364\136\113\362\376\227\201\252\002"
	"\153\004\020\261\023\330\145\061\015\206\265\263\303\053\013\241"
	"\355\161\020\376\371\050\262\307\073\324\370\142\237\203\227\243"
	"\045\152\113\300\126\142\022\014\033\355\041\247\303\006\273\350"
	"\341\143\030\341\373\332\146\100\337\216\007\121\034\144\351\025"
	"\173\234\133\157\212\126\224\126\004\147\116\070\313\230\327\251"
	"\156\016\126\133\072\376\044\364\236\373\301\155\317\025\271\374"
	"\254\326\246\312\213\077\226\375\307\332\353\326\226\075\175\331"
	"\021\142\106\241\331\220\151\165\364\306\070\232\356\132\035\355"
	"\104\267\133\242"
#define      opts_z	1
#define      opts	((&data[2263]))
	"\070"
#define      shll_z	10
#define      shll	((&data[2264]))
	"\042\051\230\133\353\036\053\327\314\333\115\365"
#define      xecc_z	15
#define      xecc	((&data[2278]))
	"\344\311\143\201\202\014\032\357\066\223\150\135\035\046\314\206"
	"\312\100\140"
#define      msg1_z	65
#define      msg1	((&data[2298]))
	"\301\075\055\142\240\253\156\135\304\256\023\102\302\216\350\013"
	"\104\004\061\373\234\054\261\004\075\052\252\306\132\136\360\243"
	"\272\106\337\325\204\271\014\362\101\373\154\351\366\376\172\210"
	"\261\360\102\040\106\110\052\121\363\343\270\216\325\263\250\176"
	"\207\325\157\335\344\241\263\006\357\164"
#define      tst1_z	22
#define      tst1	((&data[2373]))
	"\131\105\070\036\230\302\135\323\001\211\204\131\375\360\024\271"
	"\013\040\061\247\257\237\255\221\154\365\313\376\105\271"
#define      chk1_z	22
#define      chk1	((&data[2402]))
	"\121\133\060\060\027\215\067\053\220\025\134\305\130\110\174\325"
	"\035\264\163\363\315\041\254\303\253"
#define      lsto_z	1
#define      lsto	((&data[2424]))
	"\250"
#define      date_z	1
#define      date	((&data[2425]))
	"\027"
#define      tst2_z	19
#define      tst2	((&data[2427]))
	"\235\057\142\050\123\372\027\224\337\143\376\131\267\364\043\214"
	"\104\221\371\303\115"
#define      pswd_z	256
#define      pswd	((&data[2474]))
	"\021\317\051\230\157\003\325\201\261\177\064\304\316\341\306\102"
	"\042\246\223\120\342\366\367\211\100\040\371\040\337\006\275\163"
	"\347\161\222\265\154\071\336\345\217\150\365\011\300\212\112\247"
	"\335\277\123\210\157\011\023\215\042\105\237\036\114\361\252\361"
	"\235\113\236\277\237\326\332\130\104\314\123\022\154\102\323\130"
	"\206\127\251\344\011\036\232\321\330\041\316\021\116\123\313\076"
	"\221\330\170\106\260\350\265\264\013\220\011\131\022\037\160\233"
	"\053\332\243\211\346\301\335\107\152\060\255\267\042\272\377\211"
	"\134\007\375\157\171\342\210\051\311\066\302\224\141\005\110\357"
	"\114\272\051\062\057\371\036\275\131\230\342\073\375\123\233\105"
	"\224\257\360\350\104\307\023\240\001\172\264\066\326\021\202\175"
	"\312\105\257\372\143\013\163\324\102\373\161\226\025\163\223\374"
	"\210\102\261\367\216\276\177\142\151\302\235\203\265\245\217\315"
	"\211\077\126\117\205\262\142\022\110\252\165\316\134\103\310\157"
	"\275\263\021\245\215\203\300\161\144\300\144\172\002\314\172\360"
	"\064\305\206\032\006\374\040\150\217\267\247\002\014\372\136\271"
	"\223\065\244\214\015\010\373\112\253\337\033\206\007\370\045\201"
	"\170\044\274\107\177\270\277\335\016\373\046\364\333\366\137\143"
	"\372\243\364\352\020\106\316\033\105\124\356\304\324\012\026\140"
	"\206\266\326\126"
#define      msg2_z	19
#define      msg2	((&data[2759]))
	"\037\367\334\123\077\217\252\140\225\101\175\021\063\032\143\030"
	"\146\031\260\276\367\123\206\270"
#define      chk2_z	19
#define      chk2	((&data[2781]))
	"\231\364\113\217\107\233\132\242\227\354\055\106\320\075\240\271"
	"\301\120\122\237\263\105\303\344\267"
#define      rlax_z	1
#define      rlax	((&data[2804]))
	"\022"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
